import { Component, EventEmitter, Input, OnDestroy, OnInit, Output, ViewChild } from '@angular/core';
import { DateTime } from 'luxon';
import { filter } from 'rxjs/internal/operators/filter';
import { DatepickerComponent } from 'src/app/shared/components/datepicker/datepicker.component';
import { UtilsService } from 'src/app/core/services/utils.service';
import { DialogService } from 'src/app/core/services/dialog.service';
import { IonAccordionGroup } from '@ionic/angular';
import { FormControl, FormGroup } from '@angular/forms';
import { Subject, takeUntil, switchMap } from 'rxjs';
import { WorkorderService } from 'src/app/core/services/workorder.service';
import { WorkorderTaskReason, WorkorderTaskStatus } from 'src/app/core/models/workorder.model';
import { FilterService } from 'src/app/core/services/filter.service';
import { LayerService } from 'src/app/core/services/layer.service';
import { Layer, VLayerWtr } from 'src/app/core/models/layer.model';
import { DateValidator } from 'src/app/shared/form-editor/validators/date.validator';
import { MapService } from 'src/app/core/services/map/map.service';

@Component({
  selector: 'app-task-search',
  templateUrl: './task-search.component.html',
  styleUrls: ['./task-search.component.scss'],
})
export class TaskSearchComponent implements OnInit, OnDestroy {
  constructor(
    private utils: UtilsService,
    private dialogService: DialogService,
    private filterService: FilterService,
    private workorderService: WorkorderService,
    private layerService: LayerService,
    private mapService: MapService
  ) {}

  @ViewChild('accordionGroup', { static: true })
  accordionGroup: IonAccordionGroup;

  @Input() public label: string;
  @Output() public onSearchChange: EventEmitter<any> = new EventEmitter();

  public isMobile: boolean;

  public displayedActions: WorkorderTaskReason[];
  public displayedLayers: Layer[];
  public status: WorkorderTaskStatus[];
  public searchForm: FormGroup;
  public layers: Layer[];

  private currentDateValue: string;
  private vLayerWtr: VLayerWtr[];
  private actions: WorkorderTaskReason[];
  private ngUnsubscribe$: Subject<void> = new Subject();

  ngOnInit(): void {
    this.isMobile = this.utils.isMobilePlateform();
    this.createForm();
    this.getLayersAndActions();
    this.getStatus();

    this.searchForm
      .get('assObjTables')
      .valueChanges.pipe(takeUntil(this.ngUnsubscribe$))
      .subscribe((v: string[]) => {
        if (v.length > 0) {
          const layers = this.layers
            .filter((l: Layer) => v.includes(l.lyrTableName))
            .map((l) => l.astCode);
          const vLayersWtrs = this.vLayerWtr
            .filter((vlw: VLayerWtr) => layers.includes(vlw.astCode))
            .map((v) => v.wtrId);
          this.displayedActions = this.actions.filter((act) =>
            vLayersWtrs.includes(act.id)
          );
        } else {
          this.displayedActions = [...this.actions];
        }
      });

    this.searchForm
      .get('wtrIds')
      .valueChanges.pipe(takeUntil(this.ngUnsubscribe$))
      .subscribe((v: number[]) => {
        if (v.length > 0) {
          const layersName = this.vLayerWtr
            .filter((vl: VLayerWtr) => v.includes(vl.wtrId))
            .map((vl) => vl.lyrTableName);
          this.displayedLayers = this.layers.filter((layer: Layer) =>
            layersName.includes(layer.lyrTableName)
          );
        } else {
          this.displayedLayers = [...this.layers];
        }
      });

    this.searchForm.valueChanges
      .pipe(takeUntil(this.ngUnsubscribe$))
      .subscribe((form) => {
        if (form.wtrIds?.length > 0) {
          this.searchForm.patchValue(
            {
              wtrIds: form.wtrIds.filter((id: number) =>
                this.displayedActions.map((v) => v.id).includes(id)
              ),
            },
            {
              emitEvent: false,
            }
          );
          form.wtrIds = this.searchForm.get('wtrIds').value;
        }
        this.onSearchChange.next(form);
      });

      this.searchForm
        .get('wkoPlanningStartDate')
        .valueChanges.pipe(takeUntil(this.ngUnsubscribe$))
        .subscribe((v: string) => {
          let newStartDate = DateTime.fromFormat(v, "dd/MM/yyyy").toJSDate();
          if(newStartDate && v.length == 10) {
            this.workorderService.dateWorkorderSwitch = newStartDate;
            if (this.mapService.hasEventLayer('task')) {
              this.mapService.removeEventLayer('task');
            }
            this.mapService.addEventLayer('task');
          }
        });
  }

  public ngOnDestroy(): void {
    this.ngUnsubscribe$.next();
    this.ngUnsubscribe$.complete();
  }

  public openCalendar(): void {
    this.dialogService
      .open(DatepickerComponent, {
        backdrop: false,
        data: {
          multiple: true,
        },
      })
      .afterClosed()
      .pipe(
        filter(
          (dts: DateTime[]) => dts && (dts.length === 1 || dts.length === 2)
        )
      )
      .subscribe((result: DateTime[]) => {
        this.searchForm.patchValue({
          wkoPlanningStartDate: result[0].toFormat('dd/MM/yyyy'),
          wkoPlanningEndDate: (result[1] ? result[1] : result[0]).toFormat(
            'dd/MM/yyyy'
          ),
        });
      });
  }

  public getLayerLabel(layer: Layer): string {
    return layer.lyrSlabel;
  }

  public getActionLabel(action: WorkorderTaskReason): string {
    return action.wtrLlabel.charAt(0).toUpperCase() + action.wtrLlabel.slice(1);
  }

  public getStatusLabel(status: WorkorderTaskStatus): string {
    return status.wtsLlabel.charAt(0).toUpperCase() + status.wtsLlabel.slice(1);
  }

  public setCheckboxValue(controlKey: string, event: Event): void {
    this.searchForm.controls[controlKey].setValue(
      (event as CustomEvent).detail.checked
    );
  }

  public onDateKeyDown(event: any) {
    this.currentDateValue = event.target.value;
    if (!DateValidator.isKeyValid(event, this.currentDateValue)) {
      event.preventDefault();
    }
  }

  /**
   * manage keyup event on date input
   * post treatment for date format
   * @param event
   */
  public onDateKeyUp(event: any) {
    event.target.value = DateValidator.formatDate(event, this.currentDateValue);
  }

  private createForm(): void {
    const filter = this.filterService.getFilterForm();
    this.searchForm = new FormGroup({
      wtrIds: new FormControl([]),
      wtsIds: new FormControl([]),
      assObjTables: new FormControl([]),
      wkoPlanningStartDate: new FormControl(
        DateTime.fromJSDate(this.workorderService.dateWorkorderSwitch).toFormat('dd/MM/yyyy')
      ),
      wkoPlanningEndDate: new FormControl(''),
      wkoEmergency: new FormControl(false),
      wkoAppointment: new FormControl(false),
    });
    if (filter && Object.keys(filter).length > 0) {
      for (const key of Object.keys(filter)) {
        if (filter[key]) {
          this.searchForm.patchValue({ [key]: filter[key] });
        }
      }
    }
  }

  private async getLayersAndActions(): Promise<void> {
    const results = await Promise.all([
      this.layerService.getAllLayers(),
      this.layerService.getAllVLayerWtr(),
      this.workorderService.getAllWorkorderTaskReasons()
    ]);

    this.layers = results[0];
    this.vLayerWtr = results[1];
    this.actions = results[2];

    if (this.searchForm.get('assObjTables').value?.length > 0) {
      const layers = this.layers
        .filter((l: Layer) =>
          this.searchForm.get('assObjTables').value.includes(l.lyrTableName)
        )
        .map((l) => l.astCode);
      const vLayersWtrs = this.vLayerWtr
        .filter((vlw: VLayerWtr) => layers.includes(vlw.astCode))
        .map((v) => v.wtrId);
      this.displayedActions = this.actions.filter((act) =>
        vLayersWtrs.includes(act.id)
      );
    } else {
      this.displayedActions = this.actions;
    }

    if (this.searchForm.get('wtrIds').value?.length > 0) {
      const layersName = this.vLayerWtr
        .filter((vl: VLayerWtr) =>
          this.searchForm.get('wtrIds').value.includes(vl.wtrId)
        )
        .map((vl) => vl.lyrTableName);
      this.displayedLayers = this.layers.filter((layer: Layer) =>
        layersName.includes(layer.lyrTableName)
      );
    } else {
      this.displayedLayers = [...this.layers];
    }
  }

  private getStatus(): void {
    this.workorderService
      .getAllWorkorderTaskStatus()
      .then((status: WorkorderTaskStatus[]) => {
        this.status = status;
      });
  }
}

