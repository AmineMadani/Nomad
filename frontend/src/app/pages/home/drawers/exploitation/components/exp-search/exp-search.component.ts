import { Component, EventEmitter, Input, OnDestroy, OnInit, Output, ViewChild } from '@angular/core';
import { DateTime } from 'luxon';
import { filter } from 'rxjs/internal/operators/filter';
import { DatepickerComponent } from 'src/app/shared/components/datepicker/datepicker.component';
import { UtilsService } from 'src/app/core/services/utils.service';
import { DialogService } from 'src/app/core/services/dialog.service';
import { IonAccordionGroup } from '@ionic/angular';
import { FormControl, FormGroup } from '@angular/forms';
import { Subject, takeUntil, switchMap } from 'rxjs';
import { WorkorderService } from 'src/app/core/services/workorder.service';
import { WorkorderTaskReason, WorkorderTaskStatus } from 'src/app/core/models/workorder.model';
import { FilterService } from 'src/app/core/services/filter.service';
import { LayerService } from 'src/app/core/services/layer.service';
import { Layer, VLayerWtr } from 'src/app/core/models/layer.model';

@Component({
  selector: 'app-exp-search',
  templateUrl: './exp-search.component.html',
  styleUrls: ['./exp-search.component.scss'],
})
export class ExpSearchComponent implements OnInit, OnDestroy {
  constructor(
    private utils: UtilsService,
    private dialogService: DialogService,
    private filterService: FilterService,
    private workorderService: WorkorderService,
    private layerService: LayerService
  ) {}

  @ViewChild('accordionGroup', { static: true })
  accordionGroup: IonAccordionGroup;

  @Output() public onSearchChange: EventEmitter<any> = new EventEmitter();

  public isMobile: boolean;
  
  public displayedActions: WorkorderTaskReason[];
  public displayedLayers: Layer[];
  public status: WorkorderTaskStatus[];
  public searchForm: FormGroup;

  private vLayerWtr: VLayerWtr[];
  public layers: Layer[];
  private actions: WorkorderTaskReason[];
  private ngUnsubscribe$: Subject<void> = new Subject();

  ngOnInit(): void {
    this.isMobile = this.utils.isMobilePlateform();
    this.createForm();
    this.getLayersAndActions();
    this.getStatus();

    this.searchForm
      .get('assObjTables')
      .valueChanges.pipe(takeUntil(this.ngUnsubscribe$))
      .subscribe((v: string[]) => {
        if (v.length > 0) {
          const layers = this.layers
            .filter((l: Layer) => v.includes(l.lyrTableName))
            .map((l) => l.astCode);
          const vLayersWtrs = this.vLayerWtr
            .filter((vlw: VLayerWtr) => layers.includes(vlw.astCode))
            .map((v) => v.wtrId);
          this.displayedActions = this.actions.filter((act) =>
            vLayersWtrs.includes(act.id)
          );
        } else {
          this.displayedActions = [...this.actions];
        }
      });

    this.searchForm
      .get('wtrIds')
      .valueChanges.pipe(takeUntil(this.ngUnsubscribe$))
      .subscribe((v: number[]) => {
        if (v.length > 0) {
          const layersName = this.vLayerWtr
            .filter((vl: VLayerWtr) => v.includes(vl.wtrId))
            .map((vl) => vl.lyrTableName);
          this.displayedLayers = this.layers.filter((layer: Layer) =>
            layersName.includes(layer.lyrTableName)
          );
        } else {
          this.displayedLayers = [...this.layers];
        }
      });

    this.searchForm.valueChanges
      .pipe(takeUntil(this.ngUnsubscribe$))
      .subscribe((form) => {
        if (form.wtrIds?.length > 0) {
          this.searchForm.patchValue(
            {
              wtrIds: form.wtrIds.filter((id: number) =>
                this.displayedActions.map((v) => v.id).includes(id)
              ),
            },
            {
              emitEvent: false,
            }
          );
          form.wtrIds = this.searchForm.get('wtrIds').value;
        }
        this.onSearchChange.next(form);
      });
  }

  public ngOnDestroy(): void {
    this.ngUnsubscribe$.next();
    this.ngUnsubscribe$.complete();
  }

  public openCalendar(): void {
    this.dialogService
      .open(DatepickerComponent, {
        backdrop: false,
        data: {
          multiple: true,
        },
      })
      .afterClosed()
      .pipe(
        filter(
          (dts: DateTime[]) => dts && (dts.length === 1 || dts.length === 2)
        )
      )
      .subscribe((result: DateTime[]) => {
        this.searchForm.patchValue({
          wkoPlanningStartDate: result[0].toFormat('dd/MM/yyyy'),
          wkoPlanningEndDate: (result[1] ? result[1] : result[0]).toFormat(
            'dd/MM/yyyy'
          ),
        });
      });
  }

  public getLayerLabel(layer: Layer): string {
    return layer.lyrSlabel;
  }

  public getActionLabel(action: WorkorderTaskReason): string {
    return action.wtrLlabel.charAt(0).toUpperCase() + action.wtrLlabel.slice(1);
  }

  public getStatusLabel(status: WorkorderTaskStatus): string {
    return status.wtsLlabel.charAt(0).toUpperCase() + status.wtsLlabel.slice(1);
  }

  public setCheckboxValue(controlKey: string, event: Event): void {
    this.searchForm.controls[controlKey].setValue(
      (event as CustomEvent).detail.checked
    );
  }

  private createForm(): void {
    const filter = this.filterService.getFilterForm();
    this.searchForm = new FormGroup({
      wtrIds: new FormControl([]),
      wtsIds: new FormControl([]),
      assObjTables: new FormControl([]),
      wkoPlanningStartDate: new FormControl(
        DateTime.now().minus({ months: 3 }).toFormat('dd/MM/yyyy')
      ),
      wkoPlanningEndDate: new FormControl(''),
      wkoEmergency: new FormControl(false),
      wkoAppointment: new FormControl(false),
    });
    if (filter && Object.keys(filter).length > 0) {
      for (const key of Object.keys(filter)) {
        if (filter[key]) {
          this.searchForm.patchValue({ [key]: filter[key] });
        }
      }
    }
  }

  private getLayersAndActions(): void {
    this.layerService
      .getAllLayers()
      .pipe(
        switchMap((layers: Layer[]) => {
          this.layers = layers;
          return this.layerService.getAllVLayerWtr();
        }),
        switchMap((wtr: VLayerWtr[]) => { 
          this.vLayerWtr = wtr;
          return this.workorderService.getAllWorkorderTaskReasons()
        })
      )
      .subscribe((actions: WorkorderTaskReason[]) => {
        this.actions = actions;
        if (this.searchForm.get('assObjTables').value?.length > 0) {
          const layers = this.layers
            .filter((l: Layer) =>
              this.searchForm.get('assObjTables').value.includes(l.lyrTableName)
            )
            .map((l) => l.astCode);
          const vLayersWtrs = this.vLayerWtr
            .filter((vlw: VLayerWtr) => layers.includes(vlw.astCode))
            .map((v) => v.wtrId);
          this.displayedActions = this.actions.filter((act) =>
            vLayersWtrs.includes(act.id)
          );
        } else {
          this.displayedActions = actions;
        }

        if (this.searchForm.get('wtrIds').value?.length > 0) {
          const layersName = this.vLayerWtr
            .filter((vl: VLayerWtr) =>
              this.searchForm.get('wtrIds').value.includes(vl.wtrId)
            )
            .map((vl) => vl.lyrTableName);
          this.displayedLayers = this.layers.filter((layer: Layer) =>
            layersName.includes(layer.lyrTableName)
          );
        } else {
          this.displayedLayers = [...this.layers];
        }
      });
  }

  private getStatus(): void {
    this.workorderService
      .getAllWorkorderTaskStatus()
      .subscribe((status: WorkorderTaskStatus[]) => {
        this.status = status;
      });
  }
}

