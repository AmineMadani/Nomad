import { Component, OnInit, OnDestroy } from '@angular/core';
import { InfiniteScrollCustomEvent } from '@ionic/angular';
import { DateTime } from 'luxon';
import {
  Subject,
  debounceTime,
  finalize,
  fromEvent,
  switchMap,
  takeUntil,
} from 'rxjs';
import { TaskPaginated } from 'src/app/core/models/workorder.model';
import { FilterService } from 'src/app/core/services/filter.service';
import { MapLayerService } from 'src/app/core/services/map/map-layer.service';
import { MapService } from 'src/app/core/services/map/map.service';
import { WorkorderService } from 'src/app/core/services/workorder.service';

@Component({
  selector: 'app-workorder-list',
  templateUrl: './workorder-list.component.html',
  styleUrls: ['./workorder-list.component.scss'],
})
export class WorkorderListComponent implements OnInit, OnDestroy {
  constructor(
    private workorderService: WorkorderService,
    private filterService: FilterService,
    private mapService: MapService,
    private mapLayerService: MapLayerService
  ) {
    this.mapService
      .onMapLoaded()
      .pipe(
        switchMap(() => fromEvent(this.mapService.getMap(), 'moveend')),
        debounceTime(100),
        takeUntil(this.ngUnsubscribe$)
      )
      .subscribe(() => {
        if (this.isMapTasks) {
          this.loading = true;
          this.getOfflineTasks();
        }
      });
  }

  public tasks: any[] = [];
  public form: any;

  public loading: boolean = false;

  public isMapTasks: boolean = false;

  private limit: number = 20;
  private offset: number = 0;

  private ngUnsubscribe$: Subject<void> = new Subject();

  ngOnInit(): void {
    this.form = this.filterService.getFilterForm() ?? {};
    this.isMapTasks = this.workorderService.activeWorkorderSwitch;
    this.filterTasks(this.form);
  }

  ngOnDestroy(): void {
    this.ngUnsubscribe$.next();
    this.ngUnsubscribe$.complete();
  }

  public async onToggleChange(toggleEv: Event): Promise<void> {
    this.isMapTasks = (toggleEv as CustomEvent).detail.checked;
    this.workorderService.activeWorkorderSwitch = this.isMapTasks;

    // In case of switching to map tasks, addEventLayer need to be done after setting up loading
    // to avoid moveend event to be fired thus making two times the getOffline tasks
    if (this.mapService.hasEventLayer('task')) {
      this.mapService.removeEventLayer('task');
    }

    this.filterTasks(this.form);
  }

  public filterTasks(searchForm: any): void {
    this.tasks = [];
    this.limit = 20;
    this.offset = 0;
    this.form = searchForm;
    this.filterService.setFilterForm(searchForm);

    if (!this.loading) {
      this.loading = true;
      if (this.isMapTasks) {
        this.getOfflineTasks();
      } else {
        this.getOnlineTasks();
      }
    }
  }

  public onIonInfinite(ev): void {
    this.offset = this.limit;
    this.limit += 20;
    this.workorderService
      .getTasksPaginated(this.limit, this.offset, this.transformFilterForm())
      .then((t: any[]) => {
        this.tasks = [...this.tasks, ...t];
        (ev as InfiniteScrollCustomEvent).target.complete();
      });
  }

  public onCustomScrollBarStyle(): string {
    return `
    ::-webkit-scrollbar {
      width: 4px;
    }
    ::-webkit-scrollbar-track {
      background: var(--ion-color-neutral-variant-80);
    }
    ::-webkit-scrollbar-thumb {
      background: var(--ion-color-neutral-variant-30);
    }
    ::-webkit-scrollbar-thumb:hover {
      background: var(--ion-color-neutral-variant-50);
    }`;
  }

  private getOnlineTasks(): void {
    this.workorderService
      .getTasksPaginated(this.limit, this.offset, this.transformFilterForm())
      .then((e) => {
        this.tasks = e;
        this.loading = false
      });
  }

  private async getOfflineTasks(): Promise<void> {
    if (!this.mapService.hasEventLayer('task')) {
      await this.mapService.addEventLayer('task');
    }

    const filter: Map<string, any[]> = new Map();

    if (this.form?.wkoEmergency) filter.set('wkoEmergency', [true]);
    if (this.form?.wkoAppointment) filter.set('wkoAppointment', [true]);
    if (this.form?.wtrIds?.length > 0) filter.set('wtrId', this.form.wtrIds);
    if (this.form?.wtsIds?.length > 0) filter.set('wtsId', this.form.wtsIds);
    if (this.form?.assObjTables?.length > 0) filter.set('assObjTable', this.form.assObjTables);
    if (this.form?.wkoPlanningStartDate) {
      const bDate = DateTime.fromFormat(
        this.form.wkoPlanningStartDate,
        'dd/MM/yyyy'
      ).toISO();
      filter.set('wkoPlanningStartDate', [
        bDate
      ]);
      filter.set('wkoCompletionStartDate', [
        bDate
      ]);
    } else {
      filter.set('wkoPlanningStartDate', [
        DateTime.now().minus({ months: 3 }).toISO(),
      ]);
      filter.set('wkoCompletionStartDate', [
        DateTime.now().minus({ months: 3 }).toISO(),
      ])
    }
    if (!this.form?.wkoPlanningEndDate) {
      filter
        .get('wkoPlanningStartDate')
        .push(
          DateTime.now().plus({ years: 100 }).toISO()
        );
      filter.get('wkoCompletionStartDate').push(DateTime.now().plus({ years: 100 }).toISO());
    } else {
      const endDate =         DateTime.fromFormat(
        this.form.wkoPlanningEndDate,
        'dd/MM/yyyy'
      ).toISO();
      filter.get('wkoPlanningStartDate').push(endDate);
      filter.get('wkoCompletionStartDate').push(endDate);
    }

    const mapFilter = this.createMapFilter(filter);
    this.mapService.applyCreatedFilterOnMap('task', mapFilter);

    // Timeout is used to wait filters to be applied on map, then retrieve the visible features
    setTimeout(() => {
      const tasks = this.mapLayerService.getFeaturesInView('task');
      this.tasks = tasks
        .map((t) => t.properties)
        .sort(
          (a, b) =>
            new Date(b['wkoPlanningStartDate']).getTime() -
            new Date(a['wkoPlanningStartDate']).getTime()
        );
      this.loading = false;
    }, 450);
  }

  private transformFilterForm(): TaskPaginated {
    return {
      wkoEmergeny: this.form?.wkoEmergency ? true : null,
      wkoAppointment: this.form?.wkoAppointment ? true : null,
      wkoPlanningStartDate: this.form?.wkoPlanningStartDate
        ? DateTime.fromFormat(
            this.form?.wkoPlanningStartDate,
            'dd/MM/yyyy'
          ).toISO()
        : DateTime.now().minus({ months: 3 }).toISO(),
      wkoPlanningEndDate:
        this.form?.wkoPlanningEndDate ||
        this.form?.wkoPlanningEndDate?.length > 0
          ? DateTime.fromFormat(
              this.form?.wkoPlanningEndDate,
              'dd/MM/yyyy'
            ).toISO()
          : null,
      wtrIds: this.form?.wtrIds,
      wtsIds: this.form?.wtsIds,
      assObjTables: this.form?.assObjTables
    };
  }

  private createMapFilter(filters: Map<string, any[]>): any {
    const filter: any[] = ['all'];
    if (filters && filters.size > 0) {
      for (const [key, values] of filters) {
        if (!key.toLowerCase().includes('date')) {
          filter.push(['in', ['get', key], ['literal', values]]);
        }
      }
    }

    const dateFilter: any[] = ['any'];
    const planningStart = [
      'all',
      ['to-boolean', ['get', 'wkoPlanningStartDate']],
      ['>=', ['get', 'wkoPlanningStartDate'], ['literal', filters.get('wkoPlanningStartDate')[0]]],
      ['<=', ['get', 'wkoPlanningStartDate'], ['literal', filters.get('wkoPlanningStartDate')[1]]],
    ];
    const nullDate = [
      'all',
      ['!', ['to-boolean', ['get', 'wkoPlanningStartDate']]],
      ['!', ['to-boolean', ['get', 'wkoCompletionStartDate']]],
    ];
    const completionDate = [
      'all',
      ['to-boolean', ['get', 'wkoCompletionStartDate']],
      ['>=', ['get', 'wkoCompletionStartDate'], ['literal', filters.get('wkoCompletionStartDate')[0]]],
      ['<=', ['get', 'wkoCompletionStartDate'], ['literal', filters.get('wkoCompletionStartDate')[1]]],
    ]
    dateFilter.push(planningStart);
    dateFilter.push(nullDate);
    dateFilter.push(completionDate);
    filter.push(dateFilter);
    return filter;
  }
}
