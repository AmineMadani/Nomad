import { Component, OnInit, OnDestroy } from '@angular/core';
import { InfiniteScrollCustomEvent } from '@ionic/angular';
import { DateTime } from 'luxon';
import {
  Subject,
  debounceTime,
  finalize,
  fromEvent,
  switchMap,
  takeUntil,
} from 'rxjs';
import { TaskPaginated, Workorder } from 'src/app/core/models/workorder.model';
import { FilterService } from 'src/app/core/services/filter.service';
import { MapLayerService } from 'src/app/core/services/map/map-layer.service';
import { MapService } from 'src/app/core/services/map/map.service';
import { WorkorderService } from 'src/app/core/services/workorder.service';

@Component({
  selector: 'app-workorder-list',
  templateUrl: './workorder-list.component.html',
  styleUrls: ['./workorder-list.component.scss'],
})
export class WorkorderListComponent implements OnInit, OnDestroy {
  constructor(
    private workorderService: WorkorderService,
    private filterService: FilterService,
    private mapService: MapService,
    private mapLayerService: MapLayerService
  ) {
    this.mapService
      .onMapLoaded()
      .pipe(
        switchMap(() => fromEvent(this.mapService.getMap(), 'moveend')),
        debounceTime(100),
        takeUntil(this.ngUnsubscribe$)
      )
      .subscribe(() => {
        if (this.isMapTasks) {
          this.loading = true;
          this.getOfflineTasks();
        }
      });
  }

  public tasks: any[] = [];
  public form: any;

  public loading: boolean = false;

  public isMapTasks: boolean = false;

  private limit: number = 20;
  private offset: number = 0;

  private ngUnsubscribe$: Subject<void> = new Subject();

  ngOnInit(): void {
    this.form = this.filterService.getFilterForm() ?? {};
    if (this.mapService.hasEventLayer('task')) {
      this.isMapTasks = true;
    }
    this.filterTasks(this.form);
  }

  ngOnDestroy(): void {
    this.ngUnsubscribe$.next();
    this.ngUnsubscribe$.complete();
  }

  public async onToggleChange(toggleEv: Event): Promise<void> {
    this.isMapTasks = (toggleEv as CustomEvent).detail.checked;
    
    // In case of switching to map tasks, addEventLayer need to be done after setting up loading
    // to avoid moveend event to be fired thus making two times the getOffline tasks
    if (this.mapService.hasEventLayer('task')) {
      this.mapService.removeEventLayer('task');
    }

    this.filterTasks(this.form);
  }

  public filterTasks(searchForm: any): void {
    this.tasks = [];
    this.limit = 20;
    this.offset = 0;
    this.form = searchForm;
    this.filterService.setFilterForm(searchForm);

    if (!this.loading) {
      this.loading = true;
      if (this.isMapTasks) {
        this.getOfflineTasks();
      } else {
        this.getOnlineTasks();
      }
    }
  }

  public onIonInfinite(ev): void {
    this.offset = this.limit;
    this.limit += 20;
    this.workorderService
      .getTasksPaginated(this.limit, this.offset, this.transformFilterForm())
      .subscribe((t: any[]) => {
        this.tasks = [...this.tasks, ...t];
        (ev as InfiniteScrollCustomEvent).target.complete();
      });
  }

  private getOnlineTasks(): void {
    this.workorderService
      .getTasksPaginated(this.limit, this.offset, this.transformFilterForm())
      .pipe(finalize(() => (this.loading = false)))
      .subscribe((e) => (this.tasks = e));
  }

  private async getOfflineTasks(): Promise<void> {
    if (!this.mapService.hasEventLayer('task')) {
      await this.mapService.addEventLayer('task');
    }

    const filter: Map<string, any[]> = new Map();

    if (this.form?.wkoEmergency) filter.set('wkoEmergency', [true]);
    if (this.form?.wkoAppointment) filter.set('wkoAppointment', [true]);
    if (this.form?.wtrIds?.length > 0) filter.set('wtrId', this.form.wtrIds);
    if (this.form?.wtsIds?.length > 0) filter.set('wtsId', this.form.wtsIds);
    if (this.form?.assObjTables?.length > 0) filter.set('assObjTable', this.form.assObjTables);
    if (this.form?.wkoPlanningStartDate) {
      filter.set('wkoPlanningStartDate', [
        DateTime.fromFormat(
          this.form.wkoPlanningStartDate,
          'dd/MM/yyyy'
        ).toISO(),
      ]);
    } else {
      filter.set('wkoPlanningStartDate', [
        DateTime.now().minus({ months: 3 }).toISO(),
      ]);
    }
    if (this.form?.wkoPlanningEndDate) {
      filter
        .get('wkoPlanningStartDate')
        .push(
          DateTime.fromFormat(
            this.form.wkoPlanningEndDate,
            'dd/MM/yyyy'
          ).toISO()
        );
    }

    this.mapService.applyFilterOnMap('task', filter);

    // Timeout is used to wait filters to be applied on map, then retrieve the visible features
    setTimeout(() => {
      const tasks = this.mapLayerService.getFeaturesInView('task');
      this.tasks = tasks
        .map((t) => t.properties)
        .sort(
          (a, b) =>
            new Date(b['wkoPlanningStartDate']).getTime() -
            new Date(a['wkoPlanningStartDate']).getTime()
        );
      this.loading = false;
    }, 450);
  }

  private transformFilterForm(): TaskPaginated {
    return {
      wkoEmergeny: this.form?.wkoEmergency ? true : null,
      wkoAppointment: this.form?.wkoAppointment ? true : null,
      wkoPlanningStartDate: this.form?.wkoPlanningStartDate
        ? DateTime.fromFormat(
            this.form?.wkoPlanningStartDate,
            'dd/MM/yyyy'
          ).toISO()
        : DateTime.now().minus({ months: 3 }).toISO(),
      wkoPlanningEndDate:
        this.form?.wkoPlanningEndDate ||
        this.form?.wkoPlanningEndDate?.length > 0
          ? DateTime.fromFormat(
              this.form?.wkoPlanningEndDate,
              'dd/MM/yyyy'
            ).toISO()
          : null,
      wtrIds: this.form?.wtrIds,
      wtsIds: this.form?.wtsIds,
      assObjTables: this.form?.assObjTables
    };
  }
}
