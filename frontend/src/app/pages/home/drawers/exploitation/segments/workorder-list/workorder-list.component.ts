import { Component, OnInit, OnDestroy } from '@angular/core';
import { InfiniteScrollCustomEvent } from '@ionic/angular';
import {
  Subject,
  debounceTime,
  fromEvent,
  switchMap,
  takeUntil,
} from 'rxjs';
import { FilterService } from 'src/app/core/services/filter.service';
import { MapLayerService } from 'src/app/core/services/map/map-layer.service';
import { MapService } from 'src/app/core/services/map/map.service';
import { WorkorderService } from 'src/app/core/services/workorder.service';

@Component({
  selector: 'app-workorder-list',
  templateUrl: './workorder-list.component.html',
  styleUrls: ['./workorder-list.component.scss'],
})
export class WorkorderListComponent implements OnInit, OnDestroy {
  constructor(
    private workorderService: WorkorderService,
    private filterService: FilterService,
    private mapService: MapService,
    private mapLayerService: MapLayerService
  ) {
    this.mapService
      .onMapLoaded('home')
      .pipe(
        switchMap(() => fromEvent(this.mapService.getMap('home'), 'moveend')),
        debounceTime(100),
        takeUntil(this.ngUnsubscribe$)
      )
      .subscribe(() => {
        if (this.isMapTasks) {
          this.loading = true;
          this.getOfflineTasks();
        }
      });
  }

  public tasks: any[] = [];
  public form: any;

  public loading: boolean = false;

  public isMapTasks: boolean = false;

  private limit: number = 20;
  private offset: number = 0;

  private ngUnsubscribe$: Subject<void> = new Subject();

  ngOnInit(): void {
    this.form = this.filterService.getFilterForm() ?? {};
    this.isMapTasks = this.workorderService.activeWorkorderSwitch;
    this.filterTasks(this.form);
  }

  ngOnDestroy(): void {
    this.ngUnsubscribe$.next();
    this.ngUnsubscribe$.complete();
  }

  public async onToggleChange(toggleEv: Event): Promise<void> {
    this.isMapTasks = (toggleEv as CustomEvent).detail.checked;
    this.workorderService.activeWorkorderSwitch = this.isMapTasks;

    // In case of switching to map tasks, addEventLayer need to be done after setting up loading
    // to avoid moveend event to be fired thus making two times the getOffline tasks
    if (this.mapService.hasEventLayer('task')) {
      this.mapService.removeEventLayer('home', 'task');
    }

    this.filterTasks(this.form);
  }

  public async filterTasks(searchForm: any): Promise<void> {
    this.tasks = [];
    this.limit = 20;
    this.offset = 0;
    this.form = searchForm;
    this.filterService.setFilterForm(searchForm);

    if (!this.loading) {
      this.loading = true;
      if (this.isMapTasks) {
        if (this.mapService.hasEventLayer('task')) {
          this.mapService.removeEventLayer('home', 'task');
        }
        await this.getOfflineTasks();
      } else {
        this.getOnlineTasks();
      }
    }
  }

  public onIonInfinite(ev: InfiniteScrollCustomEvent): void {
    this.offset = this.limit;
    this.limit += 20;
    this.workorderService
      .getTasksPaginated(this.limit, this.offset, this.filterService.transformFilterForm())
      .then((t: any[]) => {
        this.tasks = [...this.tasks, ...t];
        ev.target.complete();
      });
  }

  public onCustomScrollBarStyle(): string {
    return `
    ::-webkit-scrollbar {
      width: 4px;
    }
    ::-webkit-scrollbar-track {
      background: var(--ion-color-neutral-variant-80);
    }
    ::-webkit-scrollbar-thumb {
      background: var(--ion-color-neutral-variant-30);
    }
    ::-webkit-scrollbar-thumb:hover {
      background: var(--ion-color-neutral-variant-50);
    }`;
  }

  private getOnlineTasks(): void {
    this.workorderService
      .getTasksPaginated(this.limit, this.offset, this.filterService.transformFilterForm())
      .then((tasks) => {
        this.tasks = tasks;
        this.loading = false;
      });
  }

  private async getOfflineTasks(): Promise<void> {
    if (!this.mapService.hasEventLayer('task')) {
      await this.mapService.addEventLayer('home', 'task');
    }

    // Timeout is used to wait filters to be applied on map, then retrieve the visible features
    setTimeout(async () => {
      const tasks = await this.mapLayerService.getFeaturesInView('home', 'task');
      this.tasks = tasks
        .filter((task) => task.id)
        .map((t) => t.properties)
        .sort(
          (a, b) =>
            new Date(b['wkoPlanningStartDate']).getTime() -
            new Date(a['wkoPlanningStartDate']).getTime()
        );
        this.loading = false;
      }, 100);
  }
}
