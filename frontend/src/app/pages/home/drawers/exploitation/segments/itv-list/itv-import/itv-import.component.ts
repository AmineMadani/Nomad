import { Component, EventEmitter, OnInit, Output } from '@angular/core';
import { ToastController } from '@ionic/angular';
import { ItvPictureDto } from 'src/app/core/models/itv.model';
import { ItvService } from 'src/app/core/services/itv.service';

@Component({
  selector: 'app-itv-import',
  templateUrl: './itv-import.component.html',
  styleUrls: ['./itv-import.component.scss'],
})
export class ItvImportComponent implements OnInit {

  @Output() onImportItvFinished: EventEmitter<void> = new EventEmitter();

  constructor(
    private toastCtrl: ToastController,
    private itvService: ItvService,
  ) { }

  public step: number = 1;
  public itvFile: File = null;
  public itvId: number = null;
  public listItvPicture: ItvPictureDto[] = [];

  ngOnInit() {}

  public onCustomScrollBarStyle(): string {
    return `
    ::-webkit-scrollbar {
      width: 4px;
    }
    ::-webkit-scrollbar-track {
      background: var(--ion-color-neutral-variant-80);
    }
    ::-webkit-scrollbar-thumb {
      background: var(--ion-color-neutral-variant-30);
    }
    ::-webkit-scrollbar-thumb:hover {
      background: var(--ion-color-neutral-variant-50);
    }`;
  }

  // ### IMPORT ITV ### //
  public async selectFileItv(event: Event) {
    const target = event.target as HTMLInputElement;
    const files = target.files as FileList;
    if (!files || files.length === 0) {
      return;
    }
    
    let file = files[0];
    target.value = null;
    this.itvFile = null;

    let extension = file.name.substring(file.name.lastIndexOf('.') + 1);

    // File has to be txt or xml
    if (extension !== 'txt' && extension !== 'xml') {
      const toast = await this.toastCtrl.create({
        message: "Le fichier doit être au format txt ou xml",
        color: 'danger',
        duration: 4000,
        position: 'bottom',
      });
  
      toast.present();
      return;
    }

    // File with size higher than 30 Mo are not allowed
    if (file.size > 30000000) {
      const toast = await this.toastCtrl.create({
        message: "Le fichier ne doit pas faire plus que 30 Mo",
        color: 'danger',
        duration: 4000,
        position: 'bottom',
      });
  
      toast.present();
      return;
    }

    this.itvFile = file;
  }

  public async importItvfile() {
    this.itvId = await this.itvService.importItvFile(this.itvFile);
    this.step = 2;
    const listItvPicture = await this.itvService.getListItvPictureByItvId(this.itvId);
    this.listItvPicture = listItvPicture.sort((a, b) => a.itpLabel.localeCompare(b.itpLabel));
  }

  // ### UPLOAD PICTURES ### //
  public async selectFilePictures(event: Event) {
    const target = event.target as HTMLInputElement;
    const files = target.files as FileList;
    if (!files || files.length === 0) {
      return;
    }

    let hasFileToLarge = false;
    for (const file of files) {
      // Check if a photo of that name is in the list
      const itvPicture = this.listItvPicture.find((itvPicture) => itvPicture.itpLabel === file.name);
      if (itvPicture) {
        // If there is one, check if it is already uploaded (in DB or right now)
        if (itvPicture.itpReference == null && itvPicture.file == null) {
          // File with size higher than 30 Mo are not allowed
          if (file.size > 30000000) {
            hasFileToLarge = true;
            continue;
          }

          itvPicture.file = file;
        }
      }
    }

    if (hasFileToLarge) {
      const toast = await this.toastCtrl.create({
        message: "Un fichier fait plus que 30 Mo, il n'a pas été pris en compte",
        color: 'danger',
        duration: 4000,
        position: 'bottom',
      });

      toast.present();
    }
    
    target.value = null;
  }

  public endPictureUpload() {
    // Check if there were any picture uploaded
    if (!this.listItvPicture.some((itvPicture) => itvPicture.file != null)) {
      // If not, display a warning
    }
    this.step = 3;
  }

  // ### SELECT WORKORDERS ### //
  public createWorkorder() {
    // TODO
  }

  public async finishItv() {
    // TODO

    const toast = await this.toastCtrl.create({
      message: "L'import a été réalisé avec succès",
      color: 'success',
      duration: 5000,
      position: 'bottom',
    });

    toast.present();
    this.onImportItvFinished.emit();
  }
}
